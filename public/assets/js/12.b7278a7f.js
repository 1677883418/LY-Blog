(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{578:function(t,a,v){"use strict";v.r(a);var _=v(5),r=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"数据流和动态表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据流和动态表"}},[t._v("#")]),t._v(" 数据流和动态表")]),t._v(" "),v("h3",{attrs:{id:"传统sql和流处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传统sql和流处理"}},[t._v("#")]),t._v(" 传统SQL和流处理")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("特征")]),t._v(" "),v("th",[t._v("SQL")]),t._v(" "),v("th",[t._v("流处理")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("处理数据的有界性")]),t._v(" "),v("td",[t._v("处理的表是有界的")]),t._v(" "),v("td",[t._v("流是一个无限元祖序列")])]),t._v(" "),v("tr",[v("td",[t._v("处理数据的完整性")]),t._v(" "),v("td",[t._v("执行查询可以访问完整的数据")]),t._v(" "),v("td",[t._v("执行查询无法访问所有的数据")])]),t._v(" "),v("tr",[v("td",[t._v("执行时间")]),t._v(" "),v("td",[t._v("批处理查询产生固定大小结果后终止")]),t._v(" "),v("td",[t._v("查询不断更新结果,永不终止")])])])]),t._v(" "),v("h3",{attrs:{id:"数据流和动态表转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据流和动态表转换"}},[t._v("#")]),t._v(" 数据流和动态表转换")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://s2.loli.net/2022/07/27/uxAq3hyBg4mJnM5.png",alt:""}})]),t._v(" "),v("blockquote",[v("p",[t._v("Stream: 数据流\nDynamic Table: 动态表\nContinuous Queries: 连续查询\nAppend-only Stream: Append-only 流（只有 INSERT 消息）\nRetract Stream: Retract 流（同时包含 INSERT 消息和 DELETE 消息）\nUpsert Stream:: Upsert 流（同时包含 UPSERT 消息和 DELETE 消息）\nChangelog: 包含 INSERT/UPDATE/DELETE 等的数据流\nState: 计算处理逻辑的状态")])]),t._v(" "),v("h3",{attrs:{id:"一致性保证语义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一致性保证语义"}},[t._v("#")]),t._v(" 一致性保证语义")]),t._v(" "),v("ul",[v("li",[t._v("At-most-once：每条数据消费至多一次，处理延迟低")]),t._v(" "),v("li",[t._v("At-least-once：每条数据消费至少一次，一条数据可能存在重复消费")]),t._v(" "),v("li",[t._v("Exactly-once("),v("strong",[t._v("最严格")]),t._v(")：每条数据都被消费且仅被消费一次，仿佛故障从未发生")])]),t._v(" "),v("h2",{attrs:{id:"exactly-once和checkpoint"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#exactly-once和checkpoint"}},[t._v("#")]),t._v(" Exactly-once和Checkpoint")]),t._v(" "),v("h3",{attrs:{id:"制作快照的时间点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#制作快照的时间点"}},[t._v("#")]),t._v(" 制作快照的时间点")]),t._v(" "),v("ul",[v("li",[t._v("状态恢复的时间点：需要等待所有处理逻辑消费完成\nsource保留状态及之前的数据。")])]),t._v(" "),v("p",[t._v("快照制作算法:")]),t._v(" "),v("ol",[v("li",[t._v("暂停处理输入的数据")]),t._v(" "),v("li",[t._v("等待后续所有处理算子消费当前已经输入的数据：")]),t._v(" "),v("li",[t._v("待2处理完后，作业所有算子复制自己的状态并保\n存到远端可靠存储；")]),t._v(" "),v("li",[t._v("恢复对输入数据的处理")])]),t._v(" "),v("h3",{attrs:{id:"checkpoint-对作业性能的影响"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#checkpoint-对作业性能的影响"}},[t._v("#")]),t._v(" Checkpoint 对作业性能的影响")]),t._v(" "),v("ol",[v("li",[t._v("解耦了快照制作和数据处理过程，各个算子制作完成状态快照后就可以正常处理数据，不用等下游算子制作完成快照；")]),t._v(" "),v("li",[t._v("在快照制作和Barrier Alignment过程中需要暂停处理数据，仍然会增加数据处理延迟；")]),t._v(" "),v("li",[t._v("快照保存到远端也有可能极为耗时。")])]),t._v(" "),v("h2",{attrs:{id:"flink端到端的exactly-once语义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flink端到端的exactly-once语义"}},[t._v("#")]),t._v(" Flink端到端的Exactly-once语义")]),t._v(" "),v("h3",{attrs:{id:"两阶段提交协议-2pc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两阶段提交协议-2pc"}},[t._v("#")]),t._v(" 两阶段提交协议（2PC）")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://img.lystu.cn/imgBed/2022/10/10/04gvg1z5hjt69dzp.png",alt:""}})]),t._v(" "),v("ul",[v("li",[t._v("Coordinator：协作者，同步和协调所有节点处理逻辑的中心节点")]),t._v(" "),v("li",[t._v("Participant：参与者，被中心节点调度的其他执行处理逻辑的业务节点")])]),t._v(" "),v("h4",{attrs:{id:"预提交阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#预提交阶段"}},[t._v("#")]),t._v(" 预提交阶段")]),t._v(" "),v("ol",[v("li",[t._v("协作者向所有参与者发送一个commit 消息;")]),t._v(" "),v("li",[t._v("每个参与的协作者收到消息后，执行事务，但是不真正提交;")]),t._v(" "),v("li",[t._v("若事务成功执行完成。发送一个消息（vote yes ) ： 执行失败.则发送一个失败的消息（vote no)")])]),t._v(" "),v("h4",{attrs:{id:"提交阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#提交阶段"}},[t._v("#")]),t._v(" 提交阶段")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("若协作者成功接收到所有的参与者vote yes的消息:")]),t._v(" "),v("ol",[v("li",[t._v("协作者向所有参与者发送一个commit 消息;")]),t._v(" "),v("li",[t._v("每个收到commit 消息的参与者释放执行事务所需的资源，并结束这次事务的执行;")]),t._v(" "),v("li",[t._v("完成步骤2后，参与者发送一个 ack 消息给协作者；")]),t._v(" "),v("li",[t._v("协作者收到所有参与者的 ack 消息后，标识该事务执行完成。")])])]),t._v(" "),v("li",[v("p",[t._v("若协作者有收到参与者vote no的消息【或者发生等待超时)")]),t._v(" "),v("ol",[v("li",[t._v("协作者向所有参与者发送一个rollback消息：")]),t._v(" "),v("li",[t._v("每个收到rollback消息的参与者回滚事务的执行操作，并释放事务所占资源；")]),t._v(" "),v("li",[t._v("完成步骤2后，参与者发送一个ack消息给协作者")]),t._v(" "),v("li",[t._v("协作者收到所有参与者的ack消息后，标识该事务成功完成回滚。")])])])]),t._v(" "),v("h4",{attrs:{id:"flink两阶段提交总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#flink两阶段提交总结"}},[t._v("#")]),t._v(" Flink两阶段提交总结")]),t._v(" "),v("ol",[v("li",[t._v("事务开启：在sink task向下游写数据之前，均会开启一个事务，后续所有写数据的操作均在这个事务中执行，事务末提交前，事务写入的数据下游不可读；")]),t._v(" "),v("li",[t._v("预提交阶段：JobManager开始下发Checkpoint Barrier,当各个处理逻辑接收到barrier后停止处理后续数据，对当前状态制作快照，此时sik也不在当前事务下继续处理数据（处理后续的数据需要新打开下一个事务）。状态制作成功则向JM发送成功的消息，失败则发送失败的消息；")]),t._v(" "),v("li",[t._v("提交阶段：若JM收到所有预提交成功的消息，则向所有处理逻辑（包括sink)发送可以提交此次事务的消息，sik接收到此消息后，则完成此次事务的提交，此时下游可以读到这次事务写入的数据；若JM有收到预提交失败的消息，则通知所有处理逻辑回滚这次事务的操作，此时sik则丢弃这次事务提交的数据下。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);